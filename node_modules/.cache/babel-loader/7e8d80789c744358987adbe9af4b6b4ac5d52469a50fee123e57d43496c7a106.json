{"ast":null,"code":"import { __rest } from \"tslib\";\nimport equal from \"@wry/equality\";\nimport { createFragmentMap, getFragmentDefinitions, getFragmentFromSelection, getMainDefinition, isField, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(query, _a, _b, variables) {\n  var aData = _a.data,\n    aRest = __rest(_a, [\"data\"]);\n  var bData = _b.data,\n    bRest = __rest(_b, [\"data\"]);\n  return equal(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n    variables: variables\n  });\n}\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n  if (aResult === bResult) {\n    return true;\n  }\n  var seenSelections = new Set();\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every(function (selection) {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n    if (isField(selection)) {\n      var resultKey = resultKeyNameFromField(selection);\n      var aResultChild = aResult && aResult[resultKey];\n      var bResultChild = bResult && bResult[resultKey];\n      var childSelectionSet = selection.selectionSet;\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n      var aChildIsArray = Array.isArray(aResultChild);\n      var bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        var length_1 = aResultChild.length;\n        if (bResultChild.length !== length_1) {\n          return false;\n        }\n        for (var i = 0; i < length_1; ++i) {\n          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n    } else {\n      var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n        return equalBySelectionSet(fragment.selectionSet,\n        // Notice that we reuse the same aResult and bResult values here,\n        // since the fragment ...spread does not specify a field name, but\n        // consists of multiple fields (within the fragment's selection set)\n        // that should be applied to the current result value(s).\n        aResult, bResult, context);\n      }\n    }\n  });\n}\nfunction selectionHasNonreactiveDirective(selection) {\n  return !!selection.directives && selection.directives.some(directiveIsNonreactive);\n}\nfunction directiveIsNonreactive(dir) {\n  return dir.name.value === \"nonreactive\";\n}","map":{"version":3,"names":["equal","createFragmentMap","getFragmentDefinitions","getFragmentFromSelection","getMainDefinition","isField","resultKeyNameFromField","shouldInclude","equalByQuery","query","_a","_b","variables","aData","data","aRest","__rest","bData","bRest","equalBySelectionSet","selectionSet","fragmentMap","aResult","bResult","context","seenSelections","Set","selections","every","selection","has","add","selectionHasNonreactiveDirective","resultKey","aResultChild","bResultChild","childSelectionSet","aChildIsArray","Array","isArray","bChildIsArray","length_1","length","i","fragment","directives","some","directiveIsNonreactive","dir","name","value"],"sources":["/Users/henilsuhagiya/Desktop/Study/Bluestone/formdata/node_modules/@apollo/src/core/equalByQuery.ts"],"sourcesContent":["import equal from \"@wry/equality\";\n\nimport type {\n  DirectiveNode,\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  SelectionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { ApolloQueryResult, OperationVariables } from \"./types.js\";\n\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getFragmentFromSelection,\n  getMainDefinition,\n  isField,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\n\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(\n  query: DocumentNode,\n  { data: aData, ...aRest }: Partial<ApolloQueryResult<unknown>>,\n  { data: bData, ...bRest }: Partial<ApolloQueryResult<unknown>>,\n  variables?: OperationVariables\n): boolean {\n  return (\n    equal(aRest, bRest) &&\n    equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      variables,\n    })\n  );\n}\n\n// Encapsulates the information used by equalBySelectionSet that does not change\n// during the recursion.\ninterface CompareContext<TVariables> {\n  fragmentMap: FragmentMap;\n  variables: TVariables | undefined;\n}\n\nfunction equalBySelectionSet(\n  selectionSet: SelectionSetNode,\n  aResult: any,\n  bResult: any,\n  context: CompareContext<OperationVariables>\n): boolean {\n  if (aResult === bResult) {\n    return true;\n  }\n\n  const seenSelections = new Set<SelectionNode>();\n\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every((selection) => {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n\n    if (isField(selection)) {\n      const resultKey = resultKeyNameFromField(selection);\n      const aResultChild = aResult && aResult[resultKey];\n      const bResultChild = bResult && bResult[resultKey];\n      const childSelectionSet = selection.selectionSet;\n\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n\n      const aChildIsArray = Array.isArray(aResultChild);\n      const bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        const length = aResultChild.length;\n        if (bResultChild.length !== length) {\n          return false;\n        }\n        for (let i = 0; i < length; ++i) {\n          if (\n            !equalBySelectionSet(\n              childSelectionSet,\n              aResultChild[i],\n              bResultChild[i],\n              context\n            )\n          ) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      return equalBySelectionSet(\n        childSelectionSet,\n        aResultChild,\n        bResultChild,\n        context\n      );\n    } else {\n      const fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n\n        return equalBySelectionSet(\n          fragment.selectionSet,\n          // Notice that we reuse the same aResult and bResult values here,\n          // since the fragment ...spread does not specify a field name, but\n          // consists of multiple fields (within the fragment's selection set)\n          // that should be applied to the current result value(s).\n          aResult,\n          bResult,\n          context\n        );\n      }\n    }\n  });\n}\n\nfunction selectionHasNonreactiveDirective(\n  selection:\n    | FieldNode\n    | InlineFragmentNode\n    | FragmentSpreadNode\n    | FragmentDefinitionNode\n): boolean {\n  return (\n    !!selection.directives && selection.directives.some(directiveIsNonreactive)\n  );\n}\n\nfunction directiveIsNonreactive(dir: DirectiveNode): boolean {\n  return dir.name.value === \"nonreactive\";\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}