{"ast":null,"code":"import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet } from \"./helpers.js\";\nconst EntryMethods = {\n  setDirty: true,\n  dispose: true,\n  forget: true // Fully remove parent Entry from LRU cache and computation graph\n};\nexport function dep(options) {\n  const depsByKey = new Map();\n  const subscribe = options && options.subscribe;\n  function depend(key) {\n    const parent = parentEntrySlot.getValue();\n    if (parent) {\n      let dep = depsByKey.get(key);\n      if (!dep) {\n        depsByKey.set(key, dep = new Set());\n      }\n      parent.dependOn(dep);\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep);\n        dep.unsubscribe = subscribe(key);\n      }\n    }\n  }\n  depend.dirty = function dirty(key, entryMethodName) {\n    const dep = depsByKey.get(key);\n    if (dep) {\n      const m = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\";\n      // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n      // because modifying a Set while iterating over it can cause elements in\n      // the Set to be removed from the Set before they've been iterated over.\n      arrayFromSet(dep).forEach(entry => entry[m]());\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n  return depend;\n}","map":{"version":3,"names":["parentEntrySlot","hasOwnProperty","maybeUnsubscribe","arrayFromSet","EntryMethods","setDirty","dispose","forget","dep","options","depsByKey","Map","subscribe","depend","key","parent","getValue","get","set","Set","dependOn","unsubscribe","dirty","entryMethodName","m","call","forEach","entry","delete"],"sources":["/Users/henilsuhagiya/Desktop/Study/Bluestone/formdata/node_modules/optimism/src/dep.ts"],"sourcesContent":["import { AnyEntry } from \"./entry.js\";\nimport { OptimisticWrapOptions } from \"./index.js\";\nimport { parentEntrySlot } from \"./context.js\";\nimport {\n  hasOwnProperty,\n  Unsubscribable,\n  maybeUnsubscribe,\n  arrayFromSet,\n } from \"./helpers.js\";\n\ntype EntryMethodName = keyof typeof EntryMethods;\nconst EntryMethods = {\n  setDirty: true, // Mark parent Entry as needing to be recomputed (default)\n  dispose: true,  // Detach parent Entry from parents and children, but leave in LRU cache\n  forget: true,   // Fully remove parent Entry from LRU cache and computation graph\n};\n\nexport type OptimisticDependencyFunction<TKey> =\n  ((key: TKey) => void) & {\n    dirty: (key: TKey, entryMethodName?: EntryMethodName) => void;\n  };\n\nexport type Dep<TKey> = Set<AnyEntry> & {\n  subscribe: OptimisticWrapOptions<[TKey]>[\"subscribe\"];\n} & Unsubscribable;\n\nexport function dep<TKey>(options?: {\n  subscribe: Dep<TKey>[\"subscribe\"];\n}) {\n  const depsByKey = new Map<TKey, Dep<TKey>>();\n  const subscribe = options && options.subscribe;\n\n  function depend(key: TKey) {\n    const parent = parentEntrySlot.getValue();\n    if (parent) {\n      let dep = depsByKey.get(key);\n      if (!dep) {\n        depsByKey.set(key, dep = new Set as Dep<TKey>);\n      }\n      parent.dependOn(dep);\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep);\n        dep.unsubscribe = subscribe(key);\n      }\n    }\n  }\n\n  depend.dirty = function dirty(\n    key: TKey,\n    entryMethodName?: EntryMethodName,\n  ) {\n    const dep = depsByKey.get(key);\n    if (dep) {\n      const m: EntryMethodName = (\n        entryMethodName &&\n        hasOwnProperty.call(EntryMethods, entryMethodName)\n      ) ? entryMethodName : \"setDirty\";\n      // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n      // because modifying a Set while iterating over it can cause elements in\n      // the Set to be removed from the Set before they've been iterated over.\n      arrayFromSet(dep).forEach(entry => entry[m]());\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n\n  return depend as OptimisticDependencyFunction<TKey>;\n}\n"],"mappings":"AAEA,SAASA,eAAe,QAAQ,cAAc;AAC9C,SACEC,cAAc,EAEdC,gBAAgB,EAChBC,YAAY,QACN,cAAc;AAGtB,MAAMC,YAAY,GAAG;EACnBC,QAAQ,EAAE,IAAI;EACdC,OAAO,EAAE,IAAI;EACbC,MAAM,EAAE,IAAI,CAAI;CACjB;AAWD,OAAM,SAAUC,GAAGA,CAAOC,OAEzB;EACC,MAAMC,SAAS,GAAG,IAAIC,GAAG,EAAmB;EAC5C,MAAMC,SAAS,GAAGH,OAAO,IAAIA,OAAO,CAACG,SAAS;EAE9C,SAASC,MAAMA,CAACC,GAAS;IACvB,MAAMC,MAAM,GAAGf,eAAe,CAACgB,QAAQ,EAAE;IACzC,IAAID,MAAM,EAAE;MACV,IAAIP,GAAG,GAAGE,SAAS,CAACO,GAAG,CAACH,GAAG,CAAC;MAC5B,IAAI,CAACN,GAAG,EAAE;QACRE,SAAS,CAACQ,GAAG,CAACJ,GAAG,EAAEN,GAAG,GAAG,IAAIW,GAAgB,CAAhB,CAAgB,CAAC;;MAEhDJ,MAAM,CAACK,QAAQ,CAACZ,GAAG,CAAC;MACpB,IAAI,OAAOI,SAAS,KAAK,UAAU,EAAE;QACnCV,gBAAgB,CAACM,GAAG,CAAC;QACrBA,GAAG,CAACa,WAAW,GAAGT,SAAS,CAACE,GAAG,CAAC;;;EAGtC;EAEAD,MAAM,CAACS,KAAK,GAAG,SAASA,KAAKA,CAC3BR,GAAS,EACTS,eAAiC;IAEjC,MAAMf,GAAG,GAAGE,SAAS,CAACO,GAAG,CAACH,GAAG,CAAC;IAC9B,IAAIN,GAAG,EAAE;MACP,MAAMgB,CAAC,GACLD,eAAe,IACftB,cAAc,CAACwB,IAAI,CAACrB,YAAY,EAAEmB,eAAe,CAAC,GAChDA,eAAe,GAAG,UAAU;MAChC;MACA;MACA;MACApB,YAAY,CAACK,GAAG,CAAC,CAACkB,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACH,CAAC,CAAC,EAAE,CAAC;MAC9Cd,SAAS,CAACkB,MAAM,CAACd,GAAG,CAAC;MACrBZ,gBAAgB,CAACM,GAAG,CAAC;;EAEzB,CAAC;EAED,OAAOK,MAA4C;AACrD"},"metadata":{},"sourceType":"module","externalDependencies":[]}