{"ast":null,"code":"import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport { WeakCache } from \"@wry/caches\";\nimport { wrap } from \"optimism\";\nimport { cacheSizes } from \"../caching/index.js\";\nfunction identity(document) {\n  return document;\n}\nvar DocumentTransform = /** @class */function () {\n  function DocumentTransform(transform, options) {\n    if (options === void 0) {\n      options = Object.create(null);\n    }\n    this.resultCache = canUseWeakSet ? new WeakSet() : new Set();\n    this.transform = transform;\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n    this.cached = options.cache !== false;\n    this.resetCache();\n  }\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  DocumentTransform.prototype.getCacheKey = function (document) {\n    return [document];\n  };\n  DocumentTransform.identity = function () {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, {\n      cache: false\n    });\n  };\n  DocumentTransform.split = function (predicate, left, right) {\n    if (right === void 0) {\n      right = DocumentTransform.identity();\n    }\n    return Object.assign(new DocumentTransform(function (document) {\n      var documentTransform = predicate(document) ? left : right;\n      return documentTransform.transformDocument(document);\n    },\n    // Reasonably assume both `left` and `right` transforms handle their own caching\n    {\n      cache: false\n    }), {\n      left: left,\n      right: right\n    });\n  };\n  /**\n   * Resets the internal cache of this transform, if it has one.\n   */\n  DocumentTransform.prototype.resetCache = function () {\n    var _this = this;\n    if (this.cached) {\n      var stableCacheKeys_1 = new Trie(canUseWeakMap);\n      this.performWork = wrap(DocumentTransform.prototype.performWork.bind(this), {\n        makeCacheKey: function (document) {\n          var cacheKeys = _this.getCacheKey(document);\n          if (cacheKeys) {\n            invariant(Array.isArray(cacheKeys), 66);\n            return stableCacheKeys_1.lookupArray(cacheKeys);\n          }\n        },\n        max: cacheSizes[\"documentTransform.cache\"],\n        cache: WeakCache\n      });\n    }\n  };\n  DocumentTransform.prototype.performWork = function (document) {\n    checkDocument(document);\n    return this.transform(document);\n  };\n  DocumentTransform.prototype.transformDocument = function (document) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n    var transformedDocument = this.performWork(document);\n    this.resultCache.add(transformedDocument);\n    return transformedDocument;\n  };\n  DocumentTransform.prototype.concat = function (otherTransform) {\n    var _this = this;\n    return Object.assign(new DocumentTransform(function (document) {\n      return otherTransform.transformDocument(_this.transformDocument(document));\n    },\n    // Reasonably assume both transforms handle their own caching\n    {\n      cache: false\n    }), {\n      left: this,\n      right: otherTransform\n    });\n  };\n  return DocumentTransform;\n}();\nexport { DocumentTransform };","map":{"version":3,"names":["Trie","canUseWeakMap","canUseWeakSet","checkDocument","invariant","WeakCache","wrap","cacheSizes","identity","document","DocumentTransform","transform","options","Object","create","resultCache","WeakSet","Set","getCacheKey","cached","cache","resetCache","prototype","split","predicate","left","right","assign","documentTransform","transformDocument","_this","stableCacheKeys_1","performWork","bind","makeCacheKey","cacheKeys","Array","isArray","lookupArray","max","has","transformedDocument","add","concat","otherTransform"],"sources":["/Users/henilsuhagiya/Desktop/Study/Bluestone/formdata/node_modules/@apollo/src/utilities/graphql/DocumentTransform.ts"],"sourcesContent":["import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\nimport { WeakCache } from \"@wry/caches\";\nimport { wrap } from \"optimism\";\nimport { cacheSizes } from \"../caching/index.js\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  /**\n   * Determines whether to cache the transformed GraphQL document. Caching can speed up repeated calls to the document transform for the same input document. Set to `false` to completely disable caching for the document transform. When disabled, this option takes precedence over the [`getCacheKey`](#getcachekey) option.\n   *\n   * The default value is `true`.\n   */\n  cache?: boolean;\n  /**\n   * Defines a custom cache key for a GraphQL document that will determine whether to re-run the document transform when given the same input GraphQL document. Returns an array that defines the cache key. Return `undefined` to disable caching for that GraphQL document.\n   *\n   * > **Note:** The items in the array may be any type, but also need to be referentially stable to guarantee a stable cache key.\n   *\n   * The default implementation of this function returns the `document` as the cache key.\n   */\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n  private cached: boolean;\n\n  private readonly resultCache =\n    canUseWeakSet ? new WeakSet<DocumentNode>() : new Set<DocumentNode>();\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          const documentTransform = predicate(document) ? left : right;\n\n          return documentTransform.transformDocument(document);\n        },\n        // Reasonably assume both `left` and `right` transforms handle their own caching\n        { cache: false }\n      ),\n      { left, right }\n    );\n  }\n\n  constructor(\n    transform: TransformFn,\n    options: DocumentTransformOptions = Object.create(null)\n  ) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n    this.cached = options.cache !== false;\n\n    this.resetCache();\n  }\n\n  /**\n   * Resets the internal cache of this transform, if it has one.\n   */\n  resetCache() {\n    if (this.cached) {\n      const stableCacheKeys = new Trie<WeakKey>(canUseWeakMap);\n      this.performWork = wrap(\n        DocumentTransform.prototype.performWork.bind(this),\n        {\n          makeCacheKey: (document) => {\n            const cacheKeys = this.getCacheKey(document);\n            if (cacheKeys) {\n              invariant(\n                Array.isArray(cacheKeys),\n                \"`getCacheKey` must return an array or undefined\"\n              );\n              return stableCacheKeys.lookupArray(cacheKeys);\n            }\n          },\n          max: cacheSizes[\"documentTransform.cache\"],\n          cache: WeakCache<any, any>,\n        }\n      );\n    }\n  }\n\n  private performWork(document: DocumentNode) {\n    checkDocument(document);\n    return this.transform(document);\n  }\n\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const transformedDocument = this.performWork(document);\n\n    this.resultCache.add(transformedDocument);\n\n    return transformedDocument;\n  }\n\n  concat(otherTransform: DocumentTransform): DocumentTransform {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          return otherTransform.transformDocument(\n            this.transformDocument(document)\n          );\n        },\n        // Reasonably assume both transforms handle their own caching\n        { cache: false }\n      ),\n      {\n        left: this,\n        right: otherTransform,\n      }\n    );\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly left?: DocumentTransform;\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly right?: DocumentTransform;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}