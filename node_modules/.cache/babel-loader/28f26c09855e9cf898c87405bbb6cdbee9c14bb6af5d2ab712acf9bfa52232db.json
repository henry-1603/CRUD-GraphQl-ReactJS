{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { isField, resultKeyNameFromField, isReference, makeReference, shouldInclude, addTypenameToDocument, getDefaultValues, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, canonicalStringify, cacheSizes } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\nfunction execSelectionSetKeyArgs(options) {\n  return [options.selectionSet, options.objectOrReference, options.context,\n  // We split out this property so we can pass different values\n  // independently without modifying options.context itself.\n  options.context.canonizeResults];\n}\nvar StoreReader = /** @class */function () {\n  function StoreReader(config) {\n    var _this = this;\n    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config)\n    });\n    this.canon = config.canon || new ObjectCanon();\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(function (options) {\n      var _a;\n      var canonizeResults = options.context.canonizeResults;\n      var peekArgs = execSelectionSetKeyArgs(options);\n      // Negate this boolean option so we can find out if we've already read\n      // this result using the other boolean value.\n      peekArgs[3] = !canonizeResults;\n      var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n      if (other) {\n        if (canonizeResults) {\n          return __assign(__assign({}, other), {\n            // If we previously read this result without canonizing it, we can\n            // reuse that result simply by canonizing it now.\n            result: _this.canon.admit(other.result)\n          });\n        }\n        // If we previously read this result with canonization enabled, we can\n        // return that canonized result as-is.\n        return other;\n      }\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      // Finally, if we didn't find any useful previous results, run the real\n      // execSelectionSetImpl method with the given options.\n      return _this.execSelectionSetImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSelectionSet\"] || 50000 /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */,\n      keyArgs: execSelectionSetKeyArgs,\n      // Note that the parameters of makeCacheKey are determined by the\n      // array returned by keyArgs.\n      makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n        }\n      }\n    });\n    this.executeSubSelectedArray = wrap(function (options) {\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] || 10000 /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */,\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n          array = _a.array,\n          context = _a.context;\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n  }\n  StoreReader.prototype.resetCanon = function () {\n    this.canon = new ObjectCanon();\n  };\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n      query = _a.query,\n      _b = _a.rootId,\n      rootId = _b === void 0 ? \"ROOT_QUERY\" : _b,\n      variables = _a.variables,\n      _c = _a.returnPartialData,\n      returnPartialData = _c === void 0 ? true : _c,\n      _d = _a.canonizeResults,\n      canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n    var policies = this.config.cache.policies;\n    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n    var rootRef = makeReference(rootId);\n    var execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: __assign({\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: canonicalStringify(variables),\n        canonizeResults: canonizeResults\n      }, extractFragmentContext(query, this.config.fragments))\n    });\n    var missing;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing: missing\n    };\n  };\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context,\n      // If result is canonical, then it could only have been previously\n      // cached by the canonizing version of executeSelectionSet, so we can\n      // avoid checking both possibilities here.\n      this.canon.isKnown(result));\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  };\n  // Uncached version of executeSelectionSet.\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n    var selectionSet = _a.selectionSet,\n      objectOrReference = _a.objectOrReference,\n      enclosingRef = _a.enclosingRef,\n      context = _a.context;\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\")\n      };\n    }\n    var variables = context.variables,\n      policies = context.policies,\n      store = context.store;\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n    var objectsToMerge = [];\n    var missing;\n    var missingMerger = new DeepMerger();\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n    function handleMissing(result, resultName) {\n      var _a;\n      if (result.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));\n      }\n      return result.result;\n    }\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a, _b;\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n      if (isField(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = resultKeyNameFromField(selection);\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2)), _a));\n          }\n        } else if (isArray(fieldValue)) {\n          fieldValue = handleMissing(_this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            enclosingRef: enclosingRef,\n            context: context\n          }), resultName);\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = _this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context: context\n          }), resultName);\n        }\n        if (fieldValue !== void 0) {\n          objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(9, selection.name.value);\n        }\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    var result = mergeDeepArray(objectsToMerge);\n    var finalResult = {\n      result: result,\n      missing: missing\n    };\n    var frozen = context.canonizeResults ? this.canon.admit(finalResult)\n    // Since this.canon is normally responsible for freezing results (only in\n    // development), freeze them manually if canonization is disabled.\n    : maybeDeepFreeze(finalResult);\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n    return frozen;\n  };\n  // Uncached version of executeSubSelectedArray.\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n    var field = _a.field,\n      array = _a.array,\n      enclosingRef = _a.enclosingRef,\n      context = _a.context;\n    var missing;\n    var missingMerger = new DeepMerger();\n    function handleMissing(childResult, i) {\n      var _a;\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n      }\n      return childResult.result;\n    }\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n    array = array.map(function (item, i) {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          enclosingRef: enclosingRef,\n          context: context\n        }), i);\n      }\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context: context\n        }), i);\n      }\n      if (globalThis.__DEV__ !== false) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n      return item;\n    });\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing: missing\n    };\n  };\n  return StoreReader;\n}();\nexport { StoreReader };\nfunction firstMissing(tree) {\n  try {\n    JSON.stringify(tree, function (_, value) {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if (isNonNullObject(value)) {\n        invariant(!isReference(value), 10, getTypenameFromStoreObject(store, value), field.name.value);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}","map":{"version":3,"names":["invariant","newInvariantError","Kind","wrap","isField","resultKeyNameFromField","isReference","makeReference","shouldInclude","addTypenameToDocument","getDefaultValues","getMainDefinition","getQueryDefinition","getFragmentFromSelection","maybeDeepFreeze","mergeDeepArray","DeepMerger","isNonNullObject","canUseWeakMap","compact","canonicalStringify","cacheSizes","maybeDependOnExistenceOfEntity","supportsResultCaching","isArray","extractFragmentContext","getTypenameFromStoreObject","shouldCanonizeResults","MissingFieldError","ObjectCanon","execSelectionSetKeyArgs","options","selectionSet","objectOrReference","context","canonizeResults","StoreReader","config","_this","knownResults","WeakMap","Map","addTypename","canon","executeSelectionSet","peekArgs","other","_a","peek","apply","__assign","result","admit","store","enclosingRef","__ref","execSelectionSetImpl","max","resultCacheMaxSize","keyArgs","makeCacheKey","parent","varString","executeSubSelectedArray","execSubSelectedArrayImpl","field","array","prototype","resetCanon","diffQueryAgainstStore","query","_b","rootId","variables","_c","returnPartialData","_d","policies","cache","rootRef","execResult","fragments","missing","firstMissing","complete","isFresh","get","latest","isKnown","rootTypenamesById","has","empty","concat","typename","getFieldValue","objectsToMerge","missingMerger","rootIdsByTypename","push","__typename","handleMissing","resultName","merge","workSet","Set","selections","forEach","selection","fieldValue","readField","fieldName","name","value","from","added","JSON","stringify","pass","fragment","lookupFragment","kind","FRAGMENT_SPREAD","fragmentMatches","add","finalResult","frozen","set","childResult","i","filter","canRead","map","item","globalThis","__DEV__","assertSelectionSetForIdValue","tree","_","workSet_1"],"sources":["/Users/henilsuhagiya/Desktop/Study/Bluestone/formdata/node_modules/@apollo/src/cache/inmemory/readFromStore.ts"],"sourcesContent":["import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type {\n  Reference,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  makeReference,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getMainDefinition,\n  getQueryDefinition,\n  getFragmentFromSelection,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  DeepMerger,\n  isNonNullObject,\n  canUseWeakMap,\n  compact,\n  canonicalStringify,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  DiffQueryAgainstStoreOptions,\n  InMemoryCacheConfig,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  maybeDependOnExistenceOfEntity,\n  supportsResultCaching,\n} from \"./entityStore.js\";\nimport {\n  isArray,\n  extractFragmentContext,\n  getTypenameFromStoreObject,\n  shouldCanonizeResults,\n} from \"./helpers.js\";\nimport type { Policies } from \"./policies.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { MissingTree } from \"../core/types/common.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  canonizeResults: boolean;\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n}\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingTree;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: readonly any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache;\n  addTypename?: boolean;\n  resultCacheMaxSize?: number;\n  canonizeResults?: boolean;\n  canon?: ObjectCanon;\n  fragments?: InMemoryCacheConfig[\"fragments\"];\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n  boolean,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions\n): ExecSelectionSetKeyArgs {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults,\n  ];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]\n  >;\n\n  private config: {\n    cache: InMemoryCache;\n    addTypename: boolean;\n    resultCacheMaxSize?: number;\n    canonizeResults: boolean;\n    fragments?: InMemoryCacheConfig[\"fragments\"];\n  };\n\n  private knownResults = new (canUseWeakMap ? WeakMap : Map)<\n    Record<string, any>,\n    SelectionSetNode\n  >();\n\n  public canon: ObjectCanon;\n  public resetCanon() {\n    this.canon = new ObjectCanon();\n  }\n\n  constructor(config: StoreReaderConfig) {\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config),\n    });\n\n    this.canon = config.canon || new ObjectCanon();\n\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(\n      (options) => {\n        const { canonizeResults } = options.context;\n\n        const peekArgs = execSelectionSetKeyArgs(options);\n\n        // Negate this boolean option so we can find out if we've already read\n        // this result using the other boolean value.\n        peekArgs[3] = !canonizeResults;\n\n        const other = this.executeSelectionSet.peek(...peekArgs);\n\n        if (other) {\n          if (canonizeResults) {\n            return {\n              ...other,\n              // If we previously read this result without canonizing it, we can\n              // reuse that result simply by canonizing it now.\n              result: this.canon.admit(other.result),\n            };\n          }\n          // If we previously read this result with canonization enabled, we can\n          // return that canonized result as-is.\n          return other;\n        }\n\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n\n        // Finally, if we didn't find any useful previous results, run the real\n        // execSelectionSetImpl method with the given options.\n        return this.execSelectionSetImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"],\n        keyArgs: execSelectionSetKeyArgs,\n        // Note that the parameters of makeCacheKey are determined by the\n        // array returned by keyArgs.\n        makeCacheKey(selectionSet, parent, context, canonizeResults) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(\n              selectionSet,\n              isReference(parent) ? parent.__ref : parent,\n              context.varString,\n              canonizeResults\n            );\n          }\n        },\n      }\n    );\n\n    this.executeSubSelectedArray = wrap(\n      (options: ExecSubSelectedArrayOptions) => {\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n        return this.execSubSelectedArrayImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"],\n        makeCacheKey({ field, array, context }) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(field, array, context.varString);\n          }\n        },\n      }\n    );\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = \"ROOT_QUERY\",\n    variables,\n    returnPartialData = true,\n    canonizeResults = this.config.canonizeResults,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        canonizeResults,\n        ...extractFragmentContext(query, this.config.fragments),\n      },\n    });\n\n    let missing: MissingFieldError[] | undefined;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [\n        new MissingFieldError(\n          firstMissing(execResult.missing)!,\n          execResult.missing,\n          query,\n          variables\n        ),\n      ];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext\n  ): boolean {\n    if (\n      supportsResultCaching(context.store) &&\n      this.knownResults.get(result) === selectionSet\n    ) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context,\n        // If result is canonical, then it could only have been previously\n        // cached by the canonizing version of executeSelectionSet, so we can\n        // avoid checking both possibilities here.\n        this.canon.isKnown(result)\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (\n      isReference(objectOrReference) &&\n      !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n      !context.store.has(objectOrReference.__ref)\n    ) {\n      return {\n        result: this.canon.empty,\n        missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const typename = store.getFieldValue<string>(\n      objectOrReference,\n      \"__typename\"\n    );\n\n    const objectsToMerge: Record<string, any>[] = [];\n    let missing: MissingTree | undefined;\n    const missingMerger = new DeepMerger();\n\n    if (\n      this.config.addTypename &&\n      typeof typename === \"string\" &&\n      !policies.rootIdsByTypename[typename]\n    ) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function handleMissing<T>(result: ExecResult<T>, resultName: string): T {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, {\n          [resultName]: result.missing,\n        });\n      }\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach((selection) => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField(\n          {\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n            from: objectOrReference,\n          },\n          context\n        );\n\n        const resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: `Can't find field '${selection.name.value}' on ${\n                isReference(objectOrReference) ?\n                  objectOrReference.__ref + \" object\"\n                : \"object \" + JSON.stringify(objectOrReference, null, 2)\n              }`,\n            });\n          }\n        } else if (isArray(fieldValue)) {\n          fieldValue = handleMissing(\n            this.executeSubSelectedArray({\n              field: selection,\n              array: fieldValue,\n              enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(\n            this.executeSelectionSet({\n              selectionSet: selection.selectionSet,\n              objectOrReference: fieldValue as StoreObject | Reference,\n              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.lookupFragment\n        );\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(`No fragment named %s`, selection.name.value);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult: ExecResult = { result, missing };\n    const frozen =\n      context.canonizeResults ?\n        this.canon.admit(finalResult)\n        // Since this.canon is normally responsible for freezing results (only in\n        // development), freeze them manually if canonization is disabled.\n      : maybeDeepFreeze(finalResult);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingTree | undefined;\n    let missingMerger = new DeepMerger<MissingTree[]>();\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, { [i]: childResult.missing });\n      }\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(\n          this.executeSubSelectedArray({\n            field,\n            array: item,\n            enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(\n          this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            objectOrReference: item,\n            enclosingRef: isReference(item) ? item : enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing,\n    };\n  }\n}\n\nfunction firstMissing(tree: MissingTree): string | undefined {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result as string;\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach((value) => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type %s returned for query field %s`,\n          getTypenameFromStoreObject(store, value),\n          field.name.value\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}