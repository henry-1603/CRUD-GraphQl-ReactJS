{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { createFulfilledPromise, createRejectedPromise } from \"../../../utilities/index.js\";\nimport { wrapPromiseWithState } from \"../../../utilities/index.js\";\nvar QUERY_REFERENCE_SYMBOL = Symbol();\nvar PROMISE_SYMBOL = Symbol();\nexport function wrapQueryRef(internalQueryRef) {\n  var _a;\n  var ref = (_a = {\n    toPromise: function () {\n      // We avoid resolving this promise with the query data because we want to\n      // discourage using the server data directly from the queryRef. Instead,\n      // the data should be accessed through `useReadQuery`. When the server\n      // data is needed, its better to use `client.query()` directly.\n      //\n      // Here we resolve with the ref itself to make using this in React Router\n      // or TanStack Router `loader` functions a bit more ergonomic e.g.\n      //\n      // function loader() {\n      //   return { queryRef: await preloadQuery(query).toPromise() }\n      // }\n      return getWrappedPromise(ref).then(function () {\n        return ref;\n      });\n    }\n  }, _a[QUERY_REFERENCE_SYMBOL] = internalQueryRef, _a[PROMISE_SYMBOL] = internalQueryRef.promise, _a);\n  return ref;\n}\nexport function getWrappedPromise(queryRef) {\n  var internalQueryRef = unwrapQueryRef(queryRef);\n  return internalQueryRef.promise.status === \"fulfilled\" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL];\n}\nexport function unwrapQueryRef(queryRef) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\nexport function updateWrappedQueryRef(queryRef, promise) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\nvar OBSERVED_CHANGED_OPTIONS = [\"canonizeResults\", \"context\", \"errorPolicy\", \"fetchPolicy\", \"refetchWritePolicy\", \"returnPartialData\"];\nvar InternalQueryReference = /** @class */function () {\n  function InternalQueryReference(observable, options) {\n    var _this = this;\n    this.key = {};\n    this.listeners = new Set();\n    this.references = 0;\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n    this.setResult();\n    this.subscribeToQuery();\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    var startDisposeTimer = function () {\n      var _a;\n      if (!_this.references) {\n        _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n      }\n    };\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n  Object.defineProperty(InternalQueryReference.prototype, \"disposed\", {\n    get: function () {\n      return this.subscription.closed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InternalQueryReference.prototype, \"watchQueryOptions\", {\n    get: function () {\n      return this.observable.options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  InternalQueryReference.prototype.reinitialize = function () {\n    var observable = this.observable;\n    var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    try {\n      if (originalFetchPolicy !== \"no-cache\") {\n        observable.resetLastResults();\n        observable.silentSetOptions({\n          fetchPolicy: \"cache-first\"\n        });\n      } else {\n        observable.silentSetOptions({\n          fetchPolicy: \"standby\"\n        });\n      }\n      this.subscribeToQuery();\n      if (originalFetchPolicy === \"no-cache\") {\n        return;\n      }\n      observable.resetDiff();\n      this.setResult();\n    } finally {\n      observable.silentSetOptions({\n        fetchPolicy: originalFetchPolicy\n      });\n    }\n  };\n  InternalQueryReference.prototype.retain = function () {\n    var _this = this;\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    var disposed = false;\n    return function () {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      _this.references--;\n      // Wait before fully disposing in case the app is running in strict mode.\n      setTimeout(function () {\n        if (!_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n  InternalQueryReference.prototype.didChangeOptions = function (watchQueryOptions) {\n    var _this = this;\n    return OBSERVED_CHANGED_OPTIONS.some(function (option) {\n      return !equal(_this.watchQueryOptions[option], watchQueryOptions[option]);\n    });\n  };\n  InternalQueryReference.prototype.applyOptions = function (watchQueryOptions) {\n    var _a = this.watchQueryOptions,\n      currentFetchPolicy = _a.fetchPolicy,\n      currentCanonizeResults = _a.canonizeResults;\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (currentFetchPolicy === \"standby\" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n    return this.promise;\n  };\n  InternalQueryReference.prototype.listen = function (listener) {\n    var _this = this;\n    this.listeners.add(listener);\n    return function () {\n      _this.listeners.delete(listener);\n    };\n  };\n  InternalQueryReference.prototype.refetch = function (variables) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  };\n  InternalQueryReference.prototype.fetchMore = function (options) {\n    return this.initiateFetch(this.observable.fetchMore(options));\n  };\n  InternalQueryReference.prototype.dispose = function () {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  };\n  InternalQueryReference.prototype.onDispose = function () {\n    // noop. overridable by options\n  };\n  InternalQueryReference.prototype.handleNext = function (result) {\n    var _a;\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n          this.result = result;\n          (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result);\n          break;\n        }\n      default:\n        {\n          // This occurs when switching to a result that is fully cached when this\n          // class is instantiated. ObservableQuery will run reobserve when\n          // subscribing, which delivers a result from the cache.\n          if (result.data === this.result.data && result.networkStatus === this.result.networkStatus) {\n            return;\n          }\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n          this.result = result;\n          this.promise = createFulfilledPromise(result);\n          this.deliver(this.promise);\n          break;\n        }\n    }\n  };\n  InternalQueryReference.prototype.handleError = function (error) {\n    var _a;\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n          break;\n        }\n      default:\n        {\n          this.promise = createRejectedPromise(error);\n          this.deliver(this.promise);\n        }\n    }\n  };\n  InternalQueryReference.prototype.deliver = function (promise) {\n    this.listeners.forEach(function (listener) {\n      return listener(promise);\n    });\n  };\n  InternalQueryReference.prototype.initiateFetch = function (returnedPromise) {\n    var _this = this;\n    this.promise = this.createPendingPromise();\n    this.promise.catch(function () {});\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise.then(function (result) {\n      var _a;\n      if (_this.promise.status === \"pending\") {\n        _this.result = result;\n        (_a = _this.resolve) === null || _a === void 0 ? void 0 : _a.call(_this, result);\n      }\n    }).catch(function () {});\n    return returnedPromise;\n  };\n  InternalQueryReference.prototype.subscribeToQuery = function () {\n    var _this = this;\n    this.subscription = this.observable.filter(function (result) {\n      return !equal(result.data, {}) && !equal(result, _this.result);\n    }).subscribe(this.handleNext, this.handleError);\n  };\n  InternalQueryReference.prototype.setResult = function () {\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    var result = this.observable.getCurrentResult(false);\n    if (equal(result, this.result)) {\n      return;\n    }\n    this.result = result;\n    this.promise = result.data && (!result.partial || this.watchQueryOptions.returnPartialData) ? createFulfilledPromise(result) : this.createPendingPromise();\n  };\n  InternalQueryReference.prototype.createPendingPromise = function () {\n    var _this = this;\n    return wrapPromiseWithState(new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    }));\n  };\n  return InternalQueryReference;\n}();\nexport { InternalQueryReference };","map":{"version":3,"names":["equal","createFulfilledPromise","createRejectedPromise","wrapPromiseWithState","QUERY_REFERENCE_SYMBOL","Symbol","PROMISE_SYMBOL","wrapQueryRef","internalQueryRef","ref","_a","toPromise","getWrappedPromise","then","promise","queryRef","unwrapQueryRef","status","updateWrappedQueryRef","OBSERVED_CHANGED_OPTIONS","InternalQueryReference","observable","options","_this","key","listeners","Set","references","handleNext","bind","handleError","dispose","onDispose","setResult","subscribeToQuery","startDisposeTimer","autoDisposeTimeoutId","setTimeout","autoDisposeTimeoutMs","Object","defineProperty","prototype","get","subscription","closed","reinitialize","originalFetchPolicy","watchQueryOptions","fetchPolicy","resetLastResults","silentSetOptions","resetDiff","retain","clearTimeout","disposed","didChangeOptions","some","option","applyOptions","currentFetchPolicy","currentCanonizeResults","canonizeResults","initiateFetch","reobserve","result","__assign","getCurrentResult","listen","listener","add","delete","refetch","variables","fetchMore","unsubscribe","data","resolve","call","networkStatus","deliver","error","resubscribeAfterError","reject","forEach","returnedPromise","createPendingPromise","catch","filter","subscribe","partial","returnPartialData","Promise"],"sources":["/Users/henilsuhagiya/Desktop/Study/Bluestone/formdata/node_modules/@apollo/src/react/internal/cache/QueryReference.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  ObservableQuery,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../../core/index.js\";\nimport type {\n  ObservableSubscription,\n  PromiseWithState,\n} from \"../../../utilities/index.js\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n} from \"../../../utilities/index.js\";\nimport type { QueryKey } from \"./types.js\";\nimport type { useBackgroundQuery, useReadQuery } from \"../../hooks/index.js\";\nimport { wrapPromiseWithState } from \"../../../utilities/index.js\";\n\ntype QueryRefPromise<TData> = PromiseWithState<ApolloQueryResult<TData>>;\n\ntype Listener<TData> = (promise: QueryRefPromise<TData>) => void;\n\ntype FetchMoreOptions<TData> = Parameters<\n  ObservableQuery<TData>[\"fetchMore\"]\n>[0];\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol();\nconst PROMISE_SYMBOL: unique symbol = Symbol();\n\n/**\n * A `QueryReference` is an opaque object returned by {@link useBackgroundQuery}.\n * A child component reading the `QueryReference` via {@link useReadQuery} will\n * suspend until the promise resolves.\n */\nexport interface QueryReference<TData = unknown, TVariables = unknown> {\n  /** @internal */\n  readonly [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData>;\n  /** @internal */\n  [PROMISE_SYMBOL]: QueryRefPromise<TData>;\n  /**\n   * A function that returns a promise that resolves when the query has finished\n   * loading. The promise resolves with the `QueryReference` itself.\n   *\n   * @remarks\n   * This method is useful for preloading queries in data loading routers, such\n   * as [React Router](https://reactrouter.com/en/main) or [TanStack Router](https://tanstack.com/router),\n   * to prevent routes from transitioning until the query has finished loading.\n   * `data` is not exposed on the promise to discourage using the data in\n   * `loader` functions and exposing it to your route components. Instead, we\n   * prefer you rely on `useReadQuery` to access the data to ensure your\n   * component can rerender with cache updates. If you need to access raw query\n   * data, use `client.query()` directly.\n   *\n   * @example\n   * Here's an example using React Router's `loader` function:\n   * ```ts\n   * import { createQueryPreloader } from \"@apollo/client\";\n   *\n   * const preloadQuery = createQueryPreloader(client);\n   *\n   * export async function loader() {\n   *   const queryRef = preloadQuery(GET_DOGS_QUERY);\n   *\n   *   return queryRef.toPromise();\n   * }\n   *\n   * export function RouteComponent() {\n   *   const queryRef = useLoaderData();\n   *   const { data } = useReadQuery(queryRef);\n   *\n   *   // ...\n   * }\n   * ```\n   *\n   * @alpha\n   */\n  toPromise(): Promise<QueryReference<TData, TVariables>>;\n}\n\ninterface InternalQueryReferenceOptions {\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<TData, TVariables extends OperationVariables>(\n  internalQueryRef: InternalQueryReference<TData>\n) {\n  const ref: QueryReference<TData, TVariables> = {\n    toPromise() {\n      // We avoid resolving this promise with the query data because we want to\n      // discourage using the server data directly from the queryRef. Instead,\n      // the data should be accessed through `useReadQuery`. When the server\n      // data is needed, its better to use `client.query()` directly.\n      //\n      // Here we resolve with the ref itself to make using this in React Router\n      // or TanStack Router `loader` functions a bit more ergonomic e.g.\n      //\n      // function loader() {\n      //   return { queryRef: await preloadQuery(query).toPromise() }\n      // }\n      return getWrappedPromise(ref).then(() => ref);\n    },\n    [QUERY_REFERENCE_SYMBOL]: internalQueryRef,\n    [PROMISE_SYMBOL]: internalQueryRef.promise,\n  };\n\n  return ref;\n}\n\nexport function getWrappedPromise<TData>(queryRef: QueryReference<TData, any>) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  return internalQueryRef.promise.status === \"fulfilled\" ?\n      internalQueryRef.promise\n    : queryRef[PROMISE_SYMBOL];\n}\n\nexport function unwrapQueryRef<TData>(\n  queryRef: QueryReference<TData>\n): InternalQueryReference<TData> {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nexport function updateWrappedQueryRef<TData>(\n  queryRef: QueryReference<TData>,\n  promise: QueryRefPromise<TData>\n) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"canonizeResults\",\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<TData = unknown> {\n  public result!: ApolloQueryResult<TData>;\n  public readonly key: QueryKey = {};\n  public readonly observable: ObservableQuery<TData>;\n\n  public promise!: QueryRefPromise<TData>;\n\n  private subscription!: ObservableSubscription;\n  private listeners = new Set<Listener<TData>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private resolve: ((result: ApolloQueryResult<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n\n  constructor(\n    observable: ObservableQuery<TData, any>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    this.setResult();\n    this.subscribeToQuery();\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get disposed() {\n    return this.subscription.closed;\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  reinitialize() {\n    const { observable } = this;\n\n    const originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n\n    try {\n      if (originalFetchPolicy !== \"no-cache\") {\n        observable.resetLastResults();\n        observable.silentSetOptions({ fetchPolicy: \"cache-first\" });\n      } else {\n        observable.silentSetOptions({ fetchPolicy: \"standby\" });\n      }\n\n      this.subscribeToQuery();\n\n      if (originalFetchPolicy === \"no-cache\") {\n        return;\n      }\n\n      observable.resetDiff();\n      this.setResult();\n    } finally {\n      observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });\n    }\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      // Wait before fully disposing in case the app is running in strict mode.\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy,\n      canonizeResults: currentCanonizeResults,\n    } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = { ...this.result, ...this.observable.getCurrentResult() };\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: FetchMoreOptions<TData>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(result: ApolloQueryResult<TData>) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n        this.result = result;\n        this.resolve?.(result);\n        break;\n      }\n      default: {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (\n          result.data === this.result.data &&\n          result.networkStatus === this.result.networkStatus\n        ) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        this.result = result;\n        this.promise = createFulfilledPromise(result);\n        this.deliver(this.promise);\n        break;\n      }\n    }\n  }\n\n  private handleError(error: ApolloError) {\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(\n      this.handleNext,\n      this.handleError\n    );\n\n    switch (this.promise.status) {\n      case \"pending\": {\n        this.reject?.(error);\n        break;\n      }\n      default: {\n        this.promise = createRejectedPromise<ApolloQueryResult<TData>>(error);\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private deliver(promise: QueryRefPromise<TData>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(returnedPromise: Promise<ApolloQueryResult<TData>>) {\n    this.promise = this.createPendingPromise();\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then((result) => {\n        if (this.promise.status === \"pending\") {\n          this.result = result;\n          this.resolve?.(result);\n        }\n      })\n      .catch(() => {});\n\n    return returnedPromise;\n  }\n\n  private subscribeToQuery() {\n    this.subscription = this.observable\n      .filter(\n        (result) => !equal(result.data, {}) && !equal(result, this.result)\n      )\n      .subscribe(this.handleNext, this.handleError);\n  }\n\n  private setResult() {\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    const result = this.observable.getCurrentResult(false);\n\n    if (equal(result, this.result)) {\n      return;\n    }\n\n    this.result = result;\n    this.promise =\n      (\n        result.data &&\n        (!result.partial || this.watchQueryOptions.returnPartialData)\n      ) ?\n        createFulfilledPromise(result)\n      : this.createPendingPromise();\n  }\n\n  private createPendingPromise() {\n    return wrapPromiseWithState(\n      new Promise<ApolloQueryResult<TData>>((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      })\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}